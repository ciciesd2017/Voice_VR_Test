<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Voice VR — Three.js 版</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        background: #0b0d10;
        color: #e5e7eb;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Noto Sans TC", sans-serif;
      }

      #ui {
        position: fixed;
        left: 16px;
        bottom: 16px;
        display: flex;
        gap: 8px;
        z-index: 10;
      }

      .btn {
        appearance: none;
        border: 1px solid #374151;
        background: #111827;
        color: #e5e7eb;
        padding: 10px 14px;
        border-radius: 12px;
        font-size: 14px;
        cursor: pointer;
        box-shadow: 0 4px 14px rgba(0, 0, 0, 0.25);
      }

      .btn:hover {
        background: #1f2937;
      }

      .tag {
        position: fixed;
        right: 16px;
        bottom: 16px;
        opacity: 0.65;
        font-size: 12px;
      }

      #loading {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: center;
        background: rgba(0, 0, 0, 0.35);
        backdrop-filter: blur(2px);
        z-index: 20;
        font-size: 14px;
      }

      #loading.hidden {
        display: none;
      }
    </style>
  </head>

  <body>
    <div id="loading" class="hidden">載入中…</div>
    <div id="ui">
      <button id="btnBg" class="btn">Background</button>
      <button id="btnModel" class="btn">Random GLTF</button>
    </div>
    <div class="tag">Three.js + WebXR</div>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";
      import { OrbitControls } from "https://unpkg.com/three@0.161.0/examples/jsm/controls/OrbitControls.js";
      import { GLTFLoader } from "https://unpkg.com/three@0.161.0/examples/jsm/loaders/GLTFLoader.js";
      import { DRACOLoader } from "https://unpkg.com/three@0.161.0/examples/jsm/loaders/DRACOLoader.js";
      import { VRButton } from "https://unpkg.com/three@0.161.0/examples/jsm/webxr/VRButton.js";

      // ====== 基本場景 ======
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.toneMappingExposure = 1.0;            // 中性曝光
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);

      // 相機與控制
      const camera = new THREE.PerspectiveCamera(
        70,
        window.innerWidth / window.innerHeight,
        0.01,
        1000
      );
      camera.position.set(0, 1.6, 3);
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 1.4, 0);
      controls.enableDamping = true;

      // 柔光
      scene.add(new THREE.HemisphereLight(0xffffff, 0x222233, 0.35));
      const dir = new THREE.DirectionalLight(0xffffff, 1.0);
      dir.position.set(5, 10, 7);
      scene.add(dir);
      const amb = new THREE.AmbientLight(0xffffff, 0.2);
      scene.add(amb);
      // const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(5, 10, 7); scene.add(dir);
      // 地面（淡淡的參考）
      // const ground = new THREE.Mesh(
      //   new THREE.CircleGeometry(8, 64),
      //   new THREE.MeshStandardMaterial({ color: 0x22252a, metalness: 0.0, roughness: 1.0 })
      // );
      // ground.rotation.x = -Math.PI / 2; ground.position.y = 0; ground.receiveShadow = true; scene.add(ground);

      // ====== 載入器 ======
      const textureLoader = new THREE.TextureLoader();
      const gltfLoader = new GLTFLoader();
      const dracoLoader = new DRACOLoader();
      dracoLoader.setDecoderPath(
        "https://unpkg.com/three@0.161.0/examples/jsm/libs/draco/"
      );
      gltfLoader.setDRACOLoader(dracoLoader);
      const pmrem = new THREE.PMREMGenerator(renderer);

      const $loading = document.getElementById("loading");
      const showLoading = (s = true) => $loading.classList.toggle("hidden", !s);

      // ====== 資產清單（沿用原始路徑） ======
      // 若你的貼圖是 stereoscopic top/bottom，請把 mode 改成 'stereoTB'（下方提供 mono 先行版本）。
      const skyboxes = [
        { url: "assets/textures/alps_field2.jpg", mode: "mono" },
        { url: "assets/textures/alps_field.jpg", mode: "stereoTB" },
        { url: "assets/textures/chess-pano-4k.jpg", mode: "stereoTB" },
        { url: "assets/textures/rogland_clear_night.jpg", mode: "stereoTB" },
        { url: "assets/textures/stierberg_sunrise.jpg", mode: "stereoTB" },
      ];

      const models = [
        "assets/models/horse_statue_01_4k.gltf/horse_statue_01_4k.gltf",
        "assets/models/concrete_cat_statue_4k.gltf/concrete_cat_statue_4k.gltf",
        "assets/models/potted_plant_02_4k.gltf/potted_plant_02_4k.gltf",
        "assets/models/rubber_duck_toy_4k.gltf/rubber_duck_toy_4k.gltf",
        "assets/models/shiba/scene.gltf",
      ];

      let skyIdx = -1;
      let modelIdx = -1;
      let currentModel = null;

      // ====== 工具：將模型置中並等比縮放至目標大小 ======
      function normalizeAndCenter(object, targetSize = 1.2) {
        const box = new THREE.Box3().setFromObject(object);
        const size = new THREE.Vector3();
        box.getSize(size);
        const center = new THREE.Vector3();
        box.getCenter(center);
        const maxDim = Math.max(size.x, size.y, size.z) || 1;
        const scale = targetSize / maxDim;
        object.scale.setScalar(scale);
        object.position.sub(center.multiplyScalar(scale)); // 置中到 (0,0,0)
      }

      // 隨機位置（前方半圓區域）
      function randomPosition() {
        const r = 1.2 + Math.random() * 1.6; // 半徑
        const theta = Math.random() * Math.PI - Math.PI / 2; // -90°..90°
        const x = Math.cos(theta) * r;
        const z = Math.sin(theta) * r - 1.2; // 稍微往前
        return new THREE.Vector3(x, 0, z);
      }

      // ====== 天幕背景（SkyDome） - 支援 mono 與 stereo top/bottom ======
      let skyMesh = null; // mono 版用
      let skyLeft = null; // stereoTB 左眼
      let skyRight = null; // stereoTB 右眼

      function disposeSky() {
        const kill = (m) => {
          if (!m) return;
          scene.remove(m);
          m.geometry.dispose();
          if (m.material.map) m.material.map.dispose();
          m.material.dispose();
        };
        kill(skyMesh);
        skyMesh = null;
        kill(skyLeft);
        skyLeft = null;
        kill(skyRight);
        skyRight = null;
      }

      function setBackgroundMono(url) {
        showLoading(true);
        textureLoader.load(
          url,
          (tex) => {
            tex.colorSpace = THREE.SRGBColorSpace;
            tex.minFilter = THREE.LinearMipmapLinearFilter;
            tex.magFilter = THREE.LinearFilter;
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;

            disposeSky();
            const geo = new THREE.SphereGeometry(60, 64, 64);
            const mat = new THREE.MeshBasicMaterial({
              map: tex,
              side: THREE.BackSide,
              depthWrite: false,
            });
            skyMesh = new THREE.Mesh(geo, mat);
            skyMesh.name = "SkyDomeMono";
            scene.add(skyMesh);

            showLoading(false);
          },
          undefined,
          (err) => {
            console.warn("載入背景失敗", err);
            showLoading(false);
          }
        );
      }

      // Stereo Top/Bottom：上半部=左眼、下半部=右眼
      function setBackgroundStereoTB(url) {
        showLoading(true);
        textureLoader.load(
          url,
          (tex) => {
            tex.colorSpace = THREE.SRGBColorSpace;
            tex.minFilter = THREE.LinearMipmapLinearFilter;
            tex.magFilter = THREE.LinearFilter;
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;

            disposeSky();
            const geo = new THREE.SphereGeometry(60, 64, 64);

            // 如果**不在 XR**（桌面預覽），用上半部做單眼顯示，避免黑畫面/重影。
            if (!renderer.xr.isPresenting) {
              const texMono = tex.clone();
              texMono.needsUpdate = true;
              texMono.repeat.set(1, 0.5);
              texMono.offset.set(0, 0.5);
              const matMono = new THREE.MeshBasicMaterial({
                map: texMono,
                side: THREE.BackSide,
                depthWrite: false,
              });
              skyMesh = new THREE.Mesh(geo, matMono);
              scene.add(skyMesh);

              showLoading(false);
              return;
            }

            // === XR 模式：左右眼分離 ===
            const texL = tex.clone();
            texL.needsUpdate = true;
            texL.repeat.set(1, 0.5);
            texL.offset.set(0, 0.5);
            const matL = new THREE.MeshBasicMaterial({
              map: texL,
              side: THREE.BackSide,
              depthWrite: false,
            });
            skyLeft = new THREE.Mesh(geo.clone(), matL);
            skyLeft.layers.set(1); // 左眼
            skyLeft.name = "SkyDomeStereoLeft";
            scene.add(skyLeft);

            const texR = tex.clone();
            texR.needsUpdate = true;
            texR.repeat.set(1, 0.5);
            texR.offset.set(0, 0.0);
            const matR = new THREE.MeshBasicMaterial({
              map: texR,
              side: THREE.BackSide,
              depthWrite: false,
            });
            skyRight = new THREE.Mesh(geo.clone(), matR);
            skyRight.layers.set(2); // 右眼
            skyRight.name = "SkyDomeStereoRight";
            scene.add(skyRight);

            showLoading(false);
          },
          undefined,
          (err) => {
            console.warn("載入背景(stereoTB)失敗", err);
            showLoading(false);
          }
        );
      }

      function setBackground(entry) {
        if (entry.mode === "stereoTB") return setBackgroundStereoTB(entry.url);
        return setBackgroundMono(entry.url);
      }

      function nextBackground() {
        skyIdx = (skyIdx + 1) % skyboxes.length;
        setBackground(skyboxes[skyIdx]);
      }

      // ====== 載入 glTF 模型 ======
      async function addModel(url) {
        showLoading(true);

        // 以 glTF 檔案所在資料夾為 base，強化相對路徑解析（含反斜線、大小寫副檔名）
        const baseURL = url.substring(0, url.lastIndexOf("/") + 1);
        const manager = new THREE.LoadingManager();
        manager.onError = (item) => console.warn("[GLTF 資源讀取失敗]", item);
        manager.onStart = (url, loaded, total) =>
          console.log("[載入開始]", url, loaded, "/", total);
        manager.onLoad = () => console.log("[載入完成]");

        const loader = new GLTFLoader(manager);
        loader.setDRACOLoader(dracoLoader);

        loader.load(
          url,
          (gltf) => {
            const root = gltf.scene || gltf.scenes[0];
            normalizeAndCenter(root, 1.2 + Math.random() * 0.6);
            root.position.copy(randomPosition());

            // 保留原始材質；僅修正色彩空間（BaseColor/Emissive 屬 sRGB）
            root.traverse((obj) => {
              if (obj.isMesh && obj.material) {
                if (obj.material.map) obj.material.map.colorSpace = THREE.SRGBColorSpace;
                if (obj.material.emissiveMap) obj.material.emissiveMap.colorSpace = THREE.SRGBColorSpace;
              }
            });

            if (currentModel) scene.remove(currentModel);
            currentModel = root;
            scene.add(currentModel);
            showLoading(false);
          },
          undefined,
          (err) => {
            console.warn("載入模型失敗", err);
            showLoading(false);
          }
        );
      }

      function nextModel() {
        modelIdx = (modelIdx + 1) % models.length;
        addModel(models[modelIdx]);
      }

      // ====== VR Button 與控制器 ======
      document.body.appendChild(VRButton.createButton(renderer));

      // 讓 VR 相機正確分派左右眼圖層（stereoTB）
      renderer.xr.addEventListener("sessionstart", () => {
        const xrCam = renderer.xr.getCamera();
        if (xrCam.isArrayCamera && xrCam.cameras?.length >= 2) {
          const leftCam = xrCam.cameras[0];
          const rightCam = xrCam.cameras[1];
          leftCam.layers.enable(1); // 看到 skyLeft
          rightCam.layers.enable(2); // 看到 skyRight
          // 確保主相機不渲染分眼層，避免桌面模式殘留
          camera.layers.disable(1);
          camera.layers.disable(2);
        }
      });

      const controller0 = renderer.xr.getController(0);
      const controller1 = renderer.xr.getController(1);
      scene.add(controller0);
      scene.add(controller1);

      function onSelectEnd(event) {
        const handedness = (event.data && event.data.handedness) || "unknown";
        if (handedness === "left") {
          nextModel();
        } else {
          nextBackground();
        }
      }

      controller0.addEventListener("selectend", onSelectEnd);
      controller1.addEventListener("selectend", onSelectEnd);

      // 可視化控制器射線（除錯用）
      function buildRay() {
        const geo = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(0, 0, -1),
        ]);
        const mat = new THREE.LineBasicMaterial({ linewidth: 2 });
        const line = new THREE.Line(geo, mat);
        line.name = "ray";
        line.scale.z = 2;
        return line;
      }
      controller0.add(buildRay());
      controller1.add(buildRay());

      // ====== 視窗調整 ======
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // ====== UI 事件 ======
      document
        .getElementById("btnBg")
        .addEventListener("click", nextBackground);
      document.getElementById("btnModel").addEventListener("click", nextModel);

      // ====== 初始化：先載一個背景和模型 ======
      nextBackground();
      nextModel();

      // ====== 主迴圈 ======
      renderer.setAnimationLoop(() => {
        controls.update();
        const camPos = camera.position;
        if (skyMesh) skyMesh.position.copy(camPos);
        if (skyLeft) skyLeft.position.copy(camPos);
        if (skyRight) skyRight.position.copy(camPos);
        renderer.render(scene, camera);
      });

      // ====== （可選）語音控制：關鍵詞觸發 ======
      // 若需要語音控制，取消下方註解即可。實務上建議加入 UI 切換啟用/停用。
      /*
    function setupVoice() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) { console.warn('此瀏覽器不支援 Web Speech API'); return; }
      const recog = new SR();
      recog.lang = 'zh-TW';
      recog.continuous = true; recog.interimResults = false;
      recog.onresult = (e) => {
        const text = e.results[e.results.length-1][0].transcript.trim();
        console.log('[voice]', text);
        if (/背景|background/i.test(text)) nextBackground();
        if (/模型|物件|gltf|model/i.test(text)) nextModel();
        if (/放大|大一點|bigger/i.test(text) && currentModel) currentModel.scale.multiplyScalar(1.2);
        if (/縮小|小一點|smaller/i.test(text) && currentModel) currentModel.scale.multiplyScalar(1/1.2);
      };
      recog.onerror = (e) => console.warn('語音錯誤', e.error);
      recog.onend = () => recog.start();
      recog.start();
    }
    // setupVoice();
    */
    </script>
  </body>
</html>
